# 使用我们的运行时(Runtime)

到目前为止，我们只是构建了区块链的各个部分。测试确保了我们迄今为止编写的代码是正确且有意义的，但我们还没有实际使用我们为`main`程序编写的任何逻辑。

下面通过使用运行时(Runtime)并在我们的区块链上实际执行业务逻辑。

## 模拟一个区块

任何区块链状态转换函数的输入都是一个交易区块。

在本教程的后面，我们将花更多时间构建适当的区块并执行它们，但现在，我们可以通过单独调用我们的 Pallets 公开的函数来“模拟”区块的所有基本操作。

### 创世状态

您的区块链状态将从一个区块转移到另一个区块。这意味着，如果Alice在第4个区块收到100个代币，那么她可以在第5个区块至少转移100个代币，依此类推。

但是用户如何从任意起始余额开始呢？

这个问题的答案对于不同的区块链可能不同，但一般来说，大多数现代区块链都从创世状态开始。这是您的区块链在“第0个区块”的起始状态。

这意味着在创世状态中设置的任何内容都可以在第1个区块中使用，并且可以引导您的区块链正常运行。

在我们的情况下，您可以在模拟第一个区块之前简单地调用函数，如`set_balance`，以建立我们的创世状态。

### 执行区块的基本步骤

让我们快速分解执行基本区块的步骤：

1. 首先，我们增加区块号，因为每个新区块都会有一个新的区块号。
2. 然后，我们遍历并执行该区块中的每个交易：
    1. 区块链的每个交易都将来自用户，因此在处理交易时，我们将增加用户的nonce。
    2. 我们将尝试执行他们想要调用的函数，例如`transfer`。
    3. 对每个交易重复此过程。

### 处理错误

Rust中的`main()`函数无法传播或处理错误。要么处理它内部的所有事情，要么你将不得不触发一个`panic`。

正如你已经知道的，触发`panic`通常不是好事，会造成程序崩溃退出。但如果出了严重的问题，这可能是你唯一能做的事情。对于我们的区块链，唯一可能导致`panic`的是导入一个与预期区块号不匹配的区块。在这种情况下，我们无能为力来“处理”这个错误。如果有人告诉我们执行错误的区块，那么我们的整个系统就有更大的问题需要解决。

然而，用户也可以提交导致错误的交易。例如，Alice试图发送超过她账户余额的资金。

我们应该`panic`吗？

绝对不！这是我们的运行时应该能够处理的那种错误，因为这种错误是预期会发生的。**一个区块可以是有效的，即使区块中的交易是无效的！**

当交易返回错误时，我们应该向用户显示错误，然后“吞下”结果。例如：

```rust
let _res = i_can_return_error().map_err(|e| eprintln!("{}", e));
```

在这种情况下，你可以看到`i_can_return_error`返回的任何错误都会被打印到控制台，但该函数的`Result`会被放置在一个未使用的变量`_res`中。

你应该非常小心地这样做。吞下错误与Rust为开发者提供的适当错误处理完全相反。然而，在我们的`main`函数中，我们真的没有选择，我们完全理解我们在这里做的事情。

在真正的区块链系统中，即使交易结果为`Err`，用户仍然会被收取交易费。这确保了用户仍然为在区块链上触发逻辑支付成本，即使函数失败。这是保持我们的区块链对DDOS和sybil攻击具有弹性的重要部分。

## 模拟你的第一个区块

现在理解了模拟你的第一个区块所需的一切吗？

按照模板提供的说明，将你的`main`函数从“Hello, World!”转换为实际执行你的区块链运行时。

在这一步结束时，一切都应该编译并运行，没有任何警告！