# 使你的系统具备实用功能

我们已经再次建立了一个新的 Pallet。

让我们添加一些功能，使其变得有用。

## 区块编号

你的区块链的区块编号存储在 System Pallet 中，因此需要公开一些函数，允许我们访问和修改区块编号。

为此，我们需要两个简单的函数：

- `fn block_number` - 一个返回当前存储的区块编号的函数。
- `fn inc_block_number` - 一个将当前区块编号加一的函数。

这应该是一个基本区块链所需的一切功能。

## 随机数

`nonce` 代表“一次使用的数字”。

在这种情况下，你的区块链上的每个用户都有一个 `nonce`，它为用户提交到区块链的每个交易提供一个唯一的序号值。

请记住，区块链是去中心化和分布式的系统，交易本身并没有一个确定的顺序。对于用户来说，我们可以通过使用这个 `nonce` 来跟踪用户在区块链上执行了多少笔交易，从而为不同的交易分配一个顺序。

为此，我们再次使用一个 `BTreeMap` 来为每个用户提供他们自己的 `nonce` 计数器。

我们的简单区块链不会使用这个值，但为了示例的目的，我们将通过创建一个 `inc_nonce` 函数来跟踪它。如果你正在创建一个更复杂的区块链，用户的 `nonce` 将成为你系统的一个重要组成部分。

## 安全数学？

我们刚刚解释了在编写 Balances Pallet 时使用安全数学的重要性。

在那种情况下，很容易看出用户如何提供恶意输入，并在我们的系统不检查数学边界的情况下导致的下溢或上溢。

然而，你会在提供的模板中注意到， System Pallet 中的这些新函数没有返回结果，因此没有提供错误处理。

这没问题吗？

正如你所注意到的，`blocknumber` 和 `nonce` 存储项只提供了加一的 API。在我们的系统中，这两个数字都用 `u32` 表示，这意味着在发生溢出之前，需要调用这些函数超过 42 亿次。

假设一个用户每区块时间内执行一笔交易，并且每 6 秒生成一个新区块，那么发生溢出需要超过 800 年的时间。因此，在这种情况下，我们更倾向于选择一个不需要错误处理的 API。

归根结底，这是一个设计决策取舍和偏好，留给开发者自己决定。本教程选择这个 API，是因为这正是 Substrate 和 Polkadot SDK 所公开的 API。使用这些函数处理错误也很符合规范，所以如果你愿意，也可以这样做。

## 构建你的 System Pallet 

按照模板中的说明完成：

1. `fn block_number`
2. `fn inc_block_number`
3. `fn inc_nonce`

然后编写测试，验证这些函数按预期工作，并且你的状态得到正确更新。完成这一步后，应该没有编译器警告！